<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>A Gift For You</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Arial', sans-serif;
    }

    #canvas-container {
      width: 100%;
      height: 100vh;
      display: block;
    }

    /* 祝福语样式 */
    #greeting {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      text-align: center;
      pointer-events: none;
      /* 让鼠标穿透文字 */
      z-index: 100;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    h1 {
      font-family: 'Brush Script MT', cursive;
      font-size: 4rem;
      margin: 0;
      color: #ffd700;
    }

    p {
      font-size: 1.2rem;
      letter-spacing: 3px;
      margin-top: 10px;
      opacity: 0.8;
    }
  </style>
</head>

<body>

  <div id="greeting">
    <h1>Merry Christmas</h1>
    <p>特别的礼物 给特别的你</p>
  </div>

  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <script>
    let scene, camera, renderer, composer;
    let tree, snow;
    let mouseX = 0;
    let targetRotation = 0;
    let windowHalfX = window.innerWidth / 2;

    init();
    animate();

    function init() {
      const container = document.getElementById('canvas-container');

      // 1. 创建场景和相机
      scene = new THREE.Scene();
      // 添加背景雾气，增加深邃感
      scene.fog = new THREE.FogExp2(0x000000, 0.0008);

      camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 2000);
      camera.position.z = 1000;
      camera.position.y = 200;
      camera.lookAt(0, 100, 0);

      // 2. 创建渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      container.appendChild(renderer.domElement);

      // --- 核心：创建圣诞树 ---
      createTree();

      // --- 核心：创建雪花 ---
      createSnow();

      // --- 后期处理：辉光效果 (Bloom) ---
      const renderScene = new THREE.RenderPass(scene, camera);
      // UnrealBloomPass 参数：分辨率, 强度, 半径, 阈值
      const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0;
      bloomPass.strength = 2.5; // 发光强度
      bloomPass.radius = 0.5;   // 发光半径

      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      // --- 事件监听 ---
      document.addEventListener('mousemove', onDocumentMouseMove);
      document.addEventListener('touchmove', onDocumentTouchMove, { passive: true });
      window.addEventListener('resize', onWindowResize);
    }

    // 创建一个圆形的发光纹理，用于粒子
    function createParticleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 32, 32);
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    function createTree() {
      const particleCount = 3500;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];

      const colorPalette = [
        new THREE.Color(0xffd700), // 金色
        new THREE.Color(0xffffff), // 白色
        new THREE.Color(0xff3333), // 红色
        new THREE.Color(0x44ff44)  // 绿色
      ];

      for (let i = 0; i < particleCount; i++) {
        // 核心算法：生成圆锥体分布的点
        // 高度 y: 从 -300 到 300
        const y = Math.random() * 600 - 300;
        // 相对高度 (0 在顶部, 1 在底部)
        const relHeight = (y + 300) / 600;

        // 半径随高度变化，底部宽，顶部窄。使用 pow 让底部更密集
        const radius = Math.pow(relHeight, 0.8) * 250;
        const angle = Math.random() * Math.PI * 2;

        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        positions.push(x, y, z);

        // 随机颜色
        const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
        colors.push(color.r, color.g, color.b);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      // 材质定义
      const material = new THREE.PointsMaterial({
        size: 8,
        map: createParticleTexture(),
        vertexColors: true, // 使用顶点颜色
        blending: THREE.AdditiveBlending, // 发光叠加模式
        depthWrite: false, // 防止粒子互相遮挡产生黑边
        transparent: true,
        opacity: 0.9
      });

      tree = new THREE.Points(geometry, material);
      scene.add(tree);

      // 添加树顶星星
      const starGeo = new THREE.SphereGeometry(10, 16, 16);
      const starMat = new THREE.MeshBasicMaterial({ color: 0xfffdcb });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, 310, 0);
      scene.add(star);
      // 给星星加一个点光源，照亮顶部
      const starLight = new THREE.PointLight(0xfffdcb, 1.5, 200);
      starLight.position.set(0, 310, 0);
      scene.add(starLight);
    }

    function createSnow() {
      const snowCount = 1000;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const velocities = []; // 存储每个雪花的速度

      for (let i = 0; i < snowCount; i++) {
        positions.push(
          Math.random() * 2000 - 1000, // x
          Math.random() * 1000 - 500,  // y
          Math.random() * 2000 - 1000  // z
        );
        velocities.push(Math.random() * 2 + 0.5); // y轴下落速度
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.userData.velocities = velocities;

      const material = new THREE.PointsMaterial({
        size: 5,
        map: createParticleTexture(),
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.6,
        color: 0xffffff
      });

      snow = new THREE.Points(geometry, material);
      scene.add(snow);
    }

    function onDocumentMouseMove(event) {
      mouseX = (event.clientX - windowHalfX) * 0.001;
    }

    function onDocumentTouchMove(event) {
      if (event.touches.length > 0) {
        mouseX = (event.touches[0].clientX - windowHalfX) * 0.001;
      }
    }

    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // 树的交互旋转
      targetRotation = mouseX * 2; // 增加一点旋转幅度
      if (tree) {
        tree.rotation.y += (targetRotation - tree.rotation.y) * 0.05;
      }

      // 雪花下落动画
      if (snow) {
        const positions = snow.geometry.attributes.position.array;
        const velocities = snow.geometry.userData.velocities;
        for (let i = 0; i < positions.length / 3; i++) {
          positions[i * 3 + 1] -= velocities[i]; // 更新 Y 坐标
          // 如果落到屏幕下方，重置到顶部
          if (positions[i * 3 + 1] < -500) {
            positions[i * 3 + 1] = 500;
          }
        }
        snow.geometry.attributes.position.needsUpdate = true;
        snow.rotation.y += 0.002; // 雪花整体缓慢旋转
      }

      // 必须使用 composer.render() 而不是 renderer.render() 才能看到发光效果
      composer.render();
    }
  </script>
</body>

</html>