<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åœ£è¯èŠ‚å¿«ä¹ï¼ï¼ï¼</title>
  <style>
    /* ================= 1. åŸºç¡€è®¾ç½® ================= */
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Microsoft YaHei', 'Songti SC', serif;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Great+Vibes&family=Monoton&family=Abril+Fatface&family=Ma+Shan+Zheng&display=swap');

    /* ================= 2. UI è§†è§‰ (V17.6.3 åŸç‰ˆæ ·å¼) ================= */
    :root {
      --glass-bg: rgba(20, 20, 25, 0.75);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.15);
      --accent-gold: #d4af37;
      --accent-gold-gradient: linear-gradient(135deg, #fceea7 0%, #d4af37 100%);
      --text-main: #ffffff;
      --text-sub: #b0b0b5;
      --panel-width: 210px;
      --ui-scale: 0.9;
    }

    @media screen and (max-height: 800px) {
      :root {
        --ui-scale: 0.8;
      }
    }

    @media screen and (min-width: 2000px) {
      :root {
        --ui-scale: 1.1;
      }
    }

    :fullscreen {
      --ui-scale: 1.0;
    }

    .glass-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(40px) saturate(180%);
      -webkit-backdrop-filter: blur(40px) saturate(180%);
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6), inset 0.5px 0.5px 0px var(--glass-highlight), inset -0.5px -0.5px 0px rgba(0, 0, 0, 0.5);
      border: 1px solid var(--glass-border);
      overflow: hidden;
      box-sizing: border-box;
    }

    #left-sidebar,
    .bottom-left-panel {
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .panel-hidden {
      transform: translateX(calc(-1 * var(--panel-width) - 50px)) scale(var(--ui-scale)) !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    .hidden {
      display: none !important;
    }

    #left-sidebar {
      position: absolute;
      top: 15px;
      left: 15px;
      width: var(--panel-width);
      height: calc(100vh - 30px);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 20;
      pointer-events: none;
      transform: scale(var(--ui-scale));
      transform-origin: top left;
    }

    .scroll-content {
      flex: 1;
      overflow-y: auto;
      pointer-events: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      scrollbar-width: none;
    }

    .scroll-content::-webkit-scrollbar {
      display: none;
    }

    .bottom-left-panel {
      position: absolute;
      bottom: 15px;
      left: 15px;
      pointer-events: auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      width: var(--panel-width);
      padding: 10px;
      box-sizing: border-box;
      transform: scale(var(--ui-scale));
      transform-origin: bottom left;
    }

    .bottom-left-panel .ui-title-main {
      grid-column: span 2;
      font-size: 11px;
      margin-bottom: 4px;
      padding-bottom: 2px;
    }

    .bottom-left-panel .elegant-btn {
      width: 100%;
      font-size: 10px;
      height: 28px;
    }

    /* ä¿®å¤ input file æ ·å¼ */
    .bottom-left-panel .elegant-btn {
      width: 100%;
      font-size: 10px;
      height: 28px;
      position: relative;
    }

    .elegant-btn input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .ui-title-main {
      font-family: 'SimSun', 'Songti SC', serif;
      font-size: 14px;
      font-weight: bold;
      color: #fff1c1;
      text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      padding-bottom: 4px;
      margin-bottom: 6px;
      letter-spacing: 2px;
      text-align: center;
    }

    .ui-title-sub {
      font-size: 12px;
      color: #b0b0b5;
      margin-top: 6px;
      margin-bottom: 3px;
      letter-spacing: 1px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .control-label {
      color: #aaa;
      font-size: 11px;
      font-weight: 700;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-bottom: 5px;
    }

    .control-row {
      display: flex;
      flex-direction: column;
      gap: 1px;
      margin-bottom: 4px;
    }

    .particle-scroll-container {
      max-height: 140px;
      overflow-y: auto;
      padding-right: 4px;
      margin-right: -4px;
      border-left: 2px solid rgba(212, 175, 55, 0.1);
      padding-left: 6px;
    }

    .particle-scroll-container::-webkit-scrollbar {
      width: 3px;
    }

    .particle-scroll-container::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 2px;
    }

    .particle-scroll-container::-webkit-scrollbar-thumb {
      background: rgba(212, 175, 55, 0.4);
      border-radius: 2px;
    }

    .elegant-btn {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(212, 175, 55, 0.3);
      color: #d4af37;
      padding: 5px 0;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 10px;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      box-sizing: border-box;
      position: relative;
      overflow: hidden;
      font-family: 'Microsoft YaHei', sans-serif;
      text-decoration: none;
    }

    .elegant-btn:hover {
      background: rgba(212, 175, 55, 0.1);
      border-color: #fff1c1;
      color: #fff;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
    }

    .elegant-btn:active {
      transform: scale(0.98);
    }

    .btn-red {
      border-color: #844;
      color: #eaa;
    }

    .btn-red:hover {
      background: #522;
      box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
    }

    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      background: transparent;
      margin: 3px 0;
    }

    input[type=range]:focus {
      outline: none;
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 1px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 1px;
    }

    input[type=range]::-webkit-slider-thumb {
      height: 9px;
      width: 9px;
      border-radius: 50%;
      background: #d4af37;
      cursor: pointer;
      -webkit-appearance: none;
      margin-top: -4px;
      box-shadow: 0 0 5px rgba(212, 175, 55, 0.8);
      border: 1px solid #000;
      transition: transform 0.1s;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      transform: scale(1.3);
      background: #fff;
    }

    .input-glass {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #eebb66;
      padding: 3px;
      font-size: 10px;
      outline: none;
      transition: 0.3s;
      border-radius: 2px;
      width: 100%;
      box-sizing: border-box;
      text-align: center;
      height: 24px;
    }

    .input-glass:focus {
      border-color: #d4af37;
      background: rgba(0, 0, 0, 0.6);
    }

    select.input-glass {
      cursor: pointer;
    }

    select.input-glass option {
      background: #000;
      color: #d4af37;
    }

    input[type="color"] {
      -webkit-appearance: none;
      border: none;
      width: 100%;
      height: 16px;
      cursor: pointer;
      padding: 0;
      background: none;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }

    #title-container {
      position: absolute;
      top: 4%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: auto;
      cursor: move;
      z-index: 50;
      transition: color 0.2s, opacity 0.5s;
      user-select: none;
      padding: 10px;
    }

    .title-line {
      margin: 0;
      transition: all 0.2s ease;
      white-space: nowrap;
      color: #fceea7;
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
    }

    .top-left-panel {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    .interaction-grid {
      display: flex;
      gap: 4px;
      margin-bottom: 4px;
    }

    .direction-pad {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 3px;
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .dir-btn {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(212, 175, 55, 0.2);
      color: #d4af37;
      text-align: center;
      cursor: pointer;
      padding: 5px 0;
      border-radius: 2px;
      font-size: 11px;
      user-select: none;
      transition: 0.2s;
    }

    .dir-btn:hover {
      background: rgba(212, 175, 55, 0.2);
      color: #fff;
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.2);
    }

    .dir-btn:active {
      background: #d4af37;
      color: #000;
    }

    #top-right-controls {
      position: absolute;
      top: 15px;
      right: 15px;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
      z-index: 50;
    }

    #webcam-wrapper {
      position: absolute;
      bottom: 15px;
      right: 15px;
      width: 160px;
      height: 120px;
      border: 1px solid rgba(212, 175, 55, 0.5);
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
      overflow: hidden;
      z-index: 20;
      pointer-events: auto;
      background: #000;
      transition: opacity 0.4s ease, transform 0.4s ease;
    }

    #webcam-wrapper.camera-hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(10px);
    }

    #webcam-canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      display: block;
    }

    #cam-status {
      position: absolute;
      bottom: 5px;
      right: 5px;
      width: 6px;
      height: 6px;
      background: #550000;
      border-radius: 50%;
      box-shadow: 0 0 4px #ff0000;
      z-index: 30;
      transition: 0.2s;
    }

    #cam-status.active {
      background: #00ff00;
      box-shadow: 0 0 6px #00ff00;
    }

    #delete-manager {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 60;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }

    #photo-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      width: 70%;
      height: 60%;
      overflow-y: auto;
      justify-content: center;
      padding: 20px;
      border: 1px solid rgba(212, 175, 55, 0.3);
      margin: 20px 0;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
    }

    .photo-item {
      width: 80px;
      height: 80px;
      position: relative;
      border: 1px solid #d4af37;
      transition: 0.2s;
      cursor: pointer;
    }

    .photo-item:hover {
      transform: scale(1.1);
      border-color: #fff;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
    }

    .photo-thumb {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .delete-x {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: #900;
      color: white;
      border-radius: 50%;
      text-align: center;
      line-height: 18px;
      font-size: 12px;
      cursor: pointer;
      font-weight: bold;
      border: 1px solid #fff;
    }

    .manager-title {
      color: #d4af37;
      font-size: 20px;
      font-family: 'Microsoft YaHei', serif;
      letter-spacing: 2px;
    }

    #loader {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #050505;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s ease-out;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 1px solid rgba(212, 175, 55, 0.1);
      border-top: 2px solid #d4af37;
      border-radius: 50%;
      animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loader-text {
      color: #d4af37;
      font-size: 12px;
      letter-spacing: 4px;
      margin-top: 25px;
      font-family: 'Cinzel', serif;
      opacity: 0.8;
    }

    #gesture-hint {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      color: rgba(212, 175, 55, 0.7);
      font-size: 10px;
      pointer-events: none;
      text-shadow: 0 0 5px #000;
      z-index: 5;
    }
  </style>
  <style>
    /* --- éƒ¨ç½²ä¸“ç”¨ï¼šé»˜è®¤éšè—ç¼–è¾‘UI --- */
    #left-sidebar,
    .bottom-left-panel,
    #top-right-controls {
      display: none !important;
      /* å¼ºåˆ¶éšè— */
    }

    /* å¦‚æœä½ æƒ³ä¿ç•™å³ä¸‹è§’çš„æ‘„åƒå¤´é¢„è§ˆï¼Œå°±ä¸åŠ ä¸‹é¢è¿™å¥ï¼›å¦‚æœä¹Ÿæƒ³éšè—ï¼Œå°±åŠ ä¸Š */
    #webcam-wrapper {
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* è°ƒæ•´æ ‡é¢˜ä½ç½®ï¼Œå› ä¸ºæ²¡æœ‰å·¦ä¾§æ äº†ï¼Œå¯ä»¥è®©æ ‡é¢˜å±…ä¸­å¾—æ›´èˆ’æœç‚¹ */
    #title-container {
      top: 4%;
      /* å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´é«˜åº¦ */
    }




    /* æ‰‹æœºç«¯é€‚é… */
    @media (max-width: 768px) {
      .line-big {
        font-size: 3rem;
      }

      .line-small {
        font-size: 1rem;
      }
    }
  </style>
  <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm" } }
    </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">SYSTEM INITIALIZING</div>
  </div>
  <div id="canvas-container"></div>
  <div id="center-message">
    <div class="msg-content">
      <div class="line-small">To My Dearest</div>
      <div class="line-big">Merry Christmas</div>
      <div class="line-small">Always with you</div>
    </div>
  </div>
  <div id="title-container">
    <h1 id="display-line1" class="title-line">Merry</h1>
    <h1 id="display-line2" class="title-line">Christmas</h1>
  </div>
  <div id="ui-layer">
    <div id="top-right-controls"><button class="elegant-btn glass-panel" id="fs-btn" onclick="toggleFullScreen()"
        style="padding: 6px 12px;">â›¶ å…¨å±æ˜¾ç¤º</button><button class="elegant-btn glass-panel" id="toggle-ui-btn"
        onclick="toggleUI()" style="padding: 6px 12px;">ğŸ‘ éšè—ç•Œé¢</button></div>
    <div id="left-sidebar" class="panel-hidden">
      <div class="top-left-panel glass-panel">
        <div class="ui-title-main">åœºæ™¯å®šåˆ¶</div>
        <div class="ui-title-sub">ç¥ç¦è¯­å½•</div>
        <div class="control-row"><input type="text" id="input-line1" class="input-glass" placeholder="ç¬¬ä¸€è¡Œæ–‡å­—"
            oninput="updateTextConfig()"><input type="text" id="input-line2" class="input-glass" placeholder="ç¬¬äºŒè¡Œæ–‡å­—"
            oninput="updateTextConfig()" style="margin-top:2px;"></div>
        <div class="ui-title-sub">å­—ä½“é£æ ¼</div>
        <select id="font-select" class="input-glass" onchange="updateTextConfig()">
          <option value="style1">ä¹¦æ³•éŸµå‘³</option>
          <option value="style2">å¤å…¸è¡¬çº¿</option>
          <option value="style3">ä¼˜é›…æ‰‹å†™</option>
          <option value="style4">è‰ºæœ¯çº¿æ¡</option>
          <option value="style5">å¤å¤é‡ç£…</option>
        </select>
        <div class="control-row">
          <div class="ui-title-sub" style="margin-top:6px;">å¤§å° & é¢œè‰²</div>
          <div style="display:flex; gap:8px; align-items:center;"><input type="range" min="50" max="250" value="100"
              id="slider-fontsize" oninput="updateTextConfig()"><input type="color" id="color-picker" value="#fceea7"
              oninput="updateTextConfig()" style="width:30px; height:20px; border:none;"></div>
        </div>
        <div class="ui-title-sub" style="border-top:1px solid rgba(255,255,255,0.05); padding-top:6px; margin-top:6px;">
          èƒŒæ™¯éŸ³ä¹</div>
        <div style="display:flex; gap:8px; margin-bottom:4px;"><button class="elegant-btn" onclick="toggleMusicPlay()"
            id="play-btn" style="flex:2; font-size:14px;">â¯</button><button class="elegant-btn" onclick="replayMusic()"
            style="flex:1; font-size:14px;">âŸ²</button></div>
        <div class="control-row"><span class="control-label" style="text-align:center;">éŸ³é‡è°ƒèŠ‚</span><input type="range"
            min="0" max="100" value="50" id="slider-volume" oninput="updateVolume(this.value)"></div>
        <div class="ui-title-sub" style="border-top:1px solid rgba(255,255,255,0.05); padding-top:6px; margin-top:6px;">
          ç²’å­æ§åˆ¶</div>
        <div class="particle-scroll-container">
          <div class="control-row"><span class="control-label">è£…é¥°å¯†åº¦ (æ ‘)</span><input type="range" min="500" max="3000"
              value="1500" id="slider-tree"></div>
          <div class="control-row"><span class="control-label">æ˜Ÿå°˜å¯†åº¦ (èƒŒæ™¯)</span><input type="range" min="500" max="5000"
              value="2500" id="slider-dust"></div>
          <div class="control-row"><span class="control-label">é›ªèŠ±æ•°é‡</span><input type="range" min="0" max="3000"
              step="100" value="1500" id="slider-snow-count" onchange="updateSnowSettings()"></div>
          <div class="control-row"><span class="control-label">é›ªèŠ±å¤§å°</span><input type="range" min="0.05" max="0.3"
              step="0.01" value="0.12" id="slider-snow-size" onchange="updateSnowSettings()"></div>
          <div class="control-row"><span class="control-label">ä¸‹è½é€Ÿåº¦</span><input type="range" min="1.0" max="8.0"
              step="0.5" value="3.5" id="slider-snow-speed" oninput="updateSnowSpeed(this.value)"></div>
        </div>
        <button class="elegant-btn" style="width:100%; margin-top:8px;" onclick="applyParticleSettings()">âš¡
          é‡ç½®åœºæ™¯</button>
      </div>
      <div class="top-left-panel glass-panel">
        <div class="ui-title-main">äº¤äº’ä¸­æ§</div>
        <div class="ui-title-sub">å½¢æ€åˆ‡æ¢</div>
        <div class="interaction-grid"><button class="elegant-btn" style="flex:1;" onclick="setMode('TREE')">èšåˆ
            (Space)</button><button class="elegant-btn" style="flex:1;" onclick="setMode('SCATTER')">æ•£å¼€ (Z)</button>
        </div>
        <button class="elegant-btn" style="width:100%;" onclick="triggerPhotoGrab()">æŠ“å–ç…§ç‰‡ (X)</button>
        <div class="control-row" style="margin-top:8px;"><span class="control-label">æ—‹è½¬é€Ÿåº¦ (æ•£å¼€)</span><input type="range"
            min="0.1" max="5.0" step="0.1" value="1.4" oninput="updateRotationSpeed(this.value)"></div>
        <div class="direction-pad">
          <div></div>
          <div class="dir-btn" onmousedown="startRotate('up')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â–²
          </div>
          <div></div>
          <div class="dir-btn" onmousedown="startRotate('left')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â—€
          </div>
          <div class="dir-btn" onclick="resetRotation()" style="font-size:10px;">â—</div>
          <div class="dir-btn" onmousedown="startRotate('right')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â–¶
          </div>
          <div></div>
          <div class="dir-btn" onmousedown="startRotate('down')" onmouseup="stopRotate()" onmouseleave="stopRotate()">â–¼
          </div>
          <div></div>
        </div>
      </div>
    </div>
    <div class="bottom-left-panel glass-panel panel-hidden">
      <div class="ui-title-main" style="font-size:12px; margin-bottom:5px;">èµ„æºç®¡ç†</div>
      <label class="elegant-btn"> + ä¸Šä¼ ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"> </label>
      <button class="elegant-btn" onclick="openDeleteManager()">â–£ ç®¡ç†ç…§ç‰‡</button>
      <label class="elegant-btn" id="music-upload-label"> â™« èƒŒæ™¯éŸ³ä¹ <input type="file" id="music-input"
          accept=".mp3,audio/mpeg"> </label>
      <button class="elegant-btn" id="toggle-cam-btn" onclick="toggleCameraDisplay()">ğŸ“· éšè—ç”»é¢</button>
    </div>
  </div>
  <div id="gesture-hint">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>
  <div id="webcam-wrapper"><canvas id="webcam-canvas" width="320" height="240"></canvas>
    <div id="cam-status"></div>
  </div>
  <video id="webcam-video" autoplay playsinline muted style="display:none"></video>
  <div id="delete-manager" class="hidden">
    <div class="manager-title">ç…§ç‰‡åº“ç®¡ç†</div>
    <div id="photo-grid"></div>
    <div class="manager-actions"><button class="elegant-btn btn-red glass-panel" onclick="clearAllPhotos()"
        style="padding: 8px 20px;">æ¸…ç©ºæ‰€æœ‰</button><button class="elegant-btn glass-panel" onclick="closeDeleteManager()"
        style="padding: 8px 20px;">å…³é—­</button></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // Clean Database Name
    const DB_NAME = "GrandTreeDB_v17_Clean";
    const EXPORTED_DATA = null;

    let CONFIG = {
      colors: { bg: 0x000000, champagneGold: 0xffd966, deepGreen: 0x03180a, accentRed: 0x990000 },
      particles: { count: 1500, dustCount: 2500, treeHeight: 24, treeRadius: 8 },
      snow: { count: 1500, range: 70, speed: 3.5, sizeBase: 0.12, sizeVar: 0.1 },
      camera: { z: 50 },
      interaction: { rotationSpeed: 1.4, grabRadius: 0.25 }
    };

    const STATE = { mode: 'TREE', focusTarget: null, focusType: 0, hand: { detected: false, x: 0, y: 0 }, rotation: { x: 0, y: 0 }, uiVisible: false, cameraVisible: true };
    let manualRotateState = { x: 0, y: 0 };
    const FONT_STYLES = { 'style1': { font: "'Ma Shan Zheng', cursive", spacing: "4px", shadow: "2px 2px 8px rgba(180,50,50,0.8)", transform: "none" }, 'style2': { font: "'Cinzel', serif", spacing: "6px", shadow: "0 0 20px rgba(255,215,0,0.5)", transform: "none" }, 'style3': { font: "'Great Vibes', cursive", spacing: "1px", shadow: "0 0 15px rgba(255,200,255,0.7)", transform: "none" }, 'style4': { font: "'Monoton', cursive", spacing: "1px", shadow: "0 0 10px #fff", transform: "none" }, 'style5': { font: "'Abril Fatface', cursive", spacing: "0px", shadow: "0 5px 15px rgba(0,0,0,0.8)", transform: "none" } };

    let db;
    function initDB() { if (EXPORTED_DATA) return Promise.resolve(null); return new Promise(r => { const q = indexedDB.open(DB_NAME, 1); q.onupgradeneeded = e => { const d = e.target.result; if (!d.objectStoreNames.contains('photos')) d.createObjectStore('photos', { keyPath: "id" }); if (!d.objectStoreNames.contains('music')) d.createObjectStore('music', { keyPath: "id" }) }; q.onsuccess = e => { db = e.target.result; r(db) }; q.onerror = () => r(null) }); }
    function savePhotoToDB(b) { if (!db) return null; const t = db.transaction('photos', "readwrite"); const i = Date.now() + Math.random().toString(); t.objectStore('photos').add({ id: i, data: b }); return i; }
    function loadPhotosFromDB() { if (EXPORTED_DATA) return Promise.resolve(EXPORTED_DATA.photos || []); if (!db) return Promise.resolve([]); return new Promise(r => { db.transaction('photos', "readonly").objectStore('photos').getAll().onsuccess = e => r(e.target.result) }); }
    function deletePhotoFromDB(i) { if (db) db.transaction('photos', "readwrite").objectStore('photos').delete(i); }
    function clearPhotosDB() { if (db) db.transaction('photos', "readwrite").objectStore('photos').clear(); }
    function saveMusicToDB(b) { if (!db) return; const t = db.transaction('music', "readwrite"); t.objectStore('music').put({ id: 'bgm', data: b }); }
    function loadMusicFromDB() { if (EXPORTED_DATA && EXPORTED_DATA.music) return Promise.resolve(dataURLtoBlob(EXPORTED_DATA.music)); if (!db) return Promise.resolve(null); return new Promise(r => { db.transaction('music', "readonly").objectStore('music').get('bgm').onsuccess = e => r(e.target.result ? e.target.result.data : null) }); }
    function dataURLtoBlob(dataurl) { var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], { type: mime }); }

    let scene, camera, renderer, composer, mainGroup, particleSystem = [], photoMeshGroup = new THREE.Group(), snowInstancedMesh, snowDummy = new THREE.Object3D(), snowData = [], clock = new THREE.Clock(), handLandmarker, videoElement, caneTexture, bgmAudio = new Audio(); bgmAudio.loop = true; let isMusicPlaying = false;
    let textGroup; // ç”¨æ¥è£…æ–‡å­—å’Œå‘¨å›´ç²’å­çš„å®¹å™¨
    let textSprite; // æ–‡å­—æœ¬ä½“
    let envMaterials = [];
    async function init() {
      if (EXPORTED_DATA) {
        document.body.classList.add('exported-mode');
        CONFIG = EXPORTED_DATA.config;
        setTimeout(() => applyTextConfig(EXPORTED_DATA.text.fontKey, EXPORTED_DATA.text.line1, EXPORTED_DATA.text.line2, EXPORTED_DATA.text.size, EXPORTED_DATA.text.color), 100);
      }

      initThree(); setupEnvironment(); setupLights(); createTextures(); createParticles(); createDust(); createSnow();
      // createDefaultPhotos();
      createCenterText();
      setupPostProcessing(); setupEvents(); animate();

      const loader = document.getElementById('loader');
      if (loader) { loader.style.opacity = 0; setTimeout(() => loader.remove(), 500); }

      try {
        await initDB();
        if (!EXPORTED_DATA) loadTextConfig();

        const ps = await loadPhotosFromDB();
        if (ps?.length > 0) { photoMeshGroup.clear(); particleSystem = particleSystem.filter(p => p.type !== 'PHOTO'); ps.forEach(i => createPhotoTexture(i.data, i.id)); }

        const ms = await loadMusicFromDB();
        if (ms) { bgmAudio.src = URL.createObjectURL(ms); if (EXPORTED_DATA) { document.body.addEventListener('click', () => { if (!isMusicPlaying) toggleMusicPlay(); }, { once: true }); } updatePlayBtnUI(false); }
      } catch (e) { console.warn(e); }

      initMediaPipe();
      initDraggableTitle();

      setMode('TREE');
    }

    function initDraggableTitle() { const t = document.getElementById('title-container'); let d = false, o = { x: 0, y: 0 }; t.onmousedown = e => { d = true; const r = t.getBoundingClientRect(); o.x = e.clientX - r.left; o.y = e.clientY - r.top; t.style.transform = 'none'; t.style.left = r.left + 'px'; t.style.top = r.top + 'px' }; window.onmousemove = e => { if (d) { t.style.left = (e.clientX - o.x) + 'px'; t.style.top = (e.clientY - o.y) + 'px' } }; window.onmouseup = () => d = false; }
    window.toggleUI = () => { STATE.uiVisible = !STATE.uiVisible; document.getElementById('left-sidebar').classList.toggle('panel-hidden', !STATE.uiVisible); document.querySelector('.bottom-left-panel').classList.toggle('panel-hidden', !STATE.uiVisible); };
    window.toggleCameraDisplay = () => { STATE.cameraVisible = !STATE.cameraVisible; document.getElementById('webcam-wrapper').classList.toggle('camera-hidden', !STATE.cameraVisible); };
    window.toggleFullScreen = () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); };
    function loadTextConfig() {
      const s = JSON.parse(localStorage.getItem('v16_text_config'));
      if (s) {
        document.getElementById('input-line1').value = s.line1 || "";
        document.getElementById('input-line2').value = s.line2 || "";
        document.getElementById('font-select').value = s.fontKey || "style1";
        document.getElementById('slider-fontsize').value = s.size || 100;
        document.getElementById('color-picker').value = s.color || "#fceea7";
        applyTextConfig(s.fontKey, s.line1, s.line2, s.size, s.color);
      }
      else {
        document.getElementById('input-line1').value = "Merry";
        document.getElementById('input-line2').value = "Christmas";
        applyTextConfig("style1", "Merry", "Christmas", 100, "#fceea7");
      }
    }
    window.updateTextConfig = () => { const k = document.getElementById('font-select').value, l1 = document.getElementById('input-line1').value, l2 = document.getElementById('input-line2').value, s = document.getElementById('slider-fontsize').value, c = document.getElementById('color-picker').value; localStorage.setItem('v16_text_config', JSON.stringify({ fontKey: k, line1: l1, line2: l2, size: s, color: c })); applyTextConfig(k, l1, l2, s, c); };
    function applyTextConfig(k, l1, l2, s, c) { const st = FONT_STYLES[k] || FONT_STYLES['style1']; const t1 = document.getElementById('display-line1'), t2 = document.getElementById('display-line2'), ct = document.getElementById('title-container'); ct.style.fontFamily = st.font; t1.innerText = l1; t2.innerText = l2; t1.style.letterSpacing = st.spacing; t2.style.letterSpacing = st.spacing; t1.style.textShadow = st.shadow; t2.style.textShadow = st.shadow; t1.style.textTransform = st.transform; t2.style.textTransform = st.transform; t1.style.color = c; t2.style.color = c; t1.style.fontSize = (0.48 * s) + "px"; t2.style.fontSize = (0.48 * s) + "px"; }

    window.toggleMusicPlay = () => { if (!bgmAudio.src) return alert("è¯·å…ˆä¸Šä¼ éŸ³ä¹"); if (isMusicPlaying) { bgmAudio.pause(); isMusicPlaying = false; } else { bgmAudio.play(); isMusicPlaying = true; } updatePlayBtnUI(isMusicPlaying); };
    window.replayMusic = () => { if (!bgmAudio.src) return; bgmAudio.currentTime = 0; bgmAudio.play(); isMusicPlaying = true; updatePlayBtnUI(true); };
    window.updateVolume = (v) => { bgmAudio.volume = v / 100; };
    function updatePlayBtnUI(p) { document.getElementById('play-btn').innerText = p ? "â¸" : "â¯"; }

    window.updateRotationSpeed = (v) => { CONFIG.interaction.rotationSpeed = parseFloat(v); };

    // window.setMode = function (mode) {
    //   STATE.mode = mode;
    //   STATE.focusTarget = null;
    //   const hint = document.getElementById('gesture-hint');
    //   if (mode === 'TREE') hint.innerText = "çŠ¶æ€: èšåˆ (åœ£è¯æ ‘)";
    //   else if (mode === 'SCATTER') hint.innerText = "çŠ¶æ€: æ•£å¼€ (æ˜Ÿäº‘)";
    //   else if (mode === 'FOCUS') hint.innerText = "çŠ¶æ€: æŠ“å–ç…§ç‰‡";
    // }

    window.setMode = function (mode) {
      STATE.mode = mode;
      STATE.focusTarget = null;

      const hint = document.getElementById('gesture-hint');
      // === æ–°å¢ï¼šè·å–æ–‡å­—å…ƒç´  ===
      const centerMsg = document.getElementById('center-message');

      if (mode === 'TREE') {
        hint.innerText = "";
        // èšåˆæ—¶ï¼Œéšè—ä¸­å¿ƒæ–‡å­—
        if (centerMsg) centerMsg.classList.remove('active');
      }
      else if (mode === 'SCATTER') {
        hint.innerText = "";
        // æ•£å¼€æ—¶ï¼Œæ˜¾ç¤ºä¸­å¿ƒæ–‡å­—
        if (centerMsg) centerMsg.classList.add('active');
      }
      else if (mode === 'FOCUS') {
        hint.innerText = "";
        // æŠ“å–ç…§ç‰‡æ—¶ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©æ˜¾ç¤ºæˆ–éšè—ï¼Œè¿™é‡Œå»ºè®®ä¿æŒæ˜¾ç¤ºï¼Œé¿å…é—ªçƒ
        if (centerMsg) centerMsg.classList.add('active');
      }
    }

    window.triggerPhotoGrab = () => {
      let cp = null, md = Infinity;
      STATE.focusType = Math.floor(Math.random() * 4);
      particleSystem.filter(p => p.type === 'PHOTO').forEach(p => {
        p.mesh.updateMatrixWorld();
        const pos = new THREE.Vector3();
        p.mesh.getWorldPosition(pos);
        const sp = pos.project(camera);
        const d = Math.hypot(sp.x, sp.y);
        if (sp.z < 1 && d < CONFIG.interaction.grabRadius) {
          if (d < md) { md = d; cp = p.mesh; }
        }
      });

      if (cp) {
        setMode('FOCUS');
        STATE.focusTarget = cp;
      } else {
        setMode('SCATTER');
      }
    };

    window.startRotate = (d) => { if (d === 'up') manualRotateState.x = -1; if (d === 'down') manualRotateState.x = 1; if (d === 'left') manualRotateState.y = -1; if (d === 'right') manualRotateState.y = 1; };
    window.stopRotate = () => { manualRotateState = { x: 0, y: 0 }; };
    window.resetRotation = () => { STATE.rotation = { x: 0, y: 0 }; if (STATE.mode !== 'TREE') setMode('TREE'); };

    // ================= V17.6.5: UI + Keyboard =================
    window.setupEvents = function () {
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      document.getElementById('file-input').addEventListener('change', (e) => {
        const files = e.target.files; if (!files.length) return;
        Array.from(files).forEach(f => {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const base64 = ev.target.result;
            const id = savePhotoToDB(base64);
            createPhotoTexture(base64, id);
          }
          reader.readAsDataURL(f);
        });
      });
      document.getElementById('music-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          saveMusicToDB(file);
          bgmAudio.src = URL.createObjectURL(file);
          bgmAudio.play().then(() => { isMusicPlaying = true; updatePlayBtnUI(true); }).catch(console.error);
        }
      });

      // --- Keyboard Controls ---
      window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

        const k = e.key.toLowerCase();
        const code = e.code;

        if (k === 'h') window.toggleUI();

        if (code === 'Space') { e.preventDefault(); setMode('TREE'); }
        if (k === 'z') setMode('SCATTER');
        if (k === 'x') triggerPhotoGrab();

        if (code === 'ArrowUp') manualRotateState.x = -1;
        if (code === 'ArrowDown') manualRotateState.x = 1;
        if (code === 'ArrowLeft') manualRotateState.y = -1;
        if (code === 'ArrowRight') manualRotateState.y = 1;
      });

      window.addEventListener('keyup', (e) => {
        const code = e.code;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(code)) {
          manualRotateState = { x: 0, y: 0 };
        }
      });
    }


    function initThree() { const c = document.getElementById('canvas-container'); scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bg); scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01); camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 2, CONFIG.camera.z); renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.2; c.appendChild(renderer.domElement); mainGroup = new THREE.Group(); scene.add(mainGroup); }
    function setupEnvironment() { const p = new THREE.PMREMGenerator(renderer); scene.environment = p.fromScene(new RoomEnvironment(), 0.04).texture; }
    function setupLights() { scene.add(new THREE.AmbientLight(0xffffff, 0.6)); const i = new THREE.PointLight(0xffaa00, 2, 20); i.position.set(0, 5, 0); mainGroup.add(i); const s1 = new THREE.SpotLight(0xffcc66, 1200); s1.position.set(30, 40, 40); s1.angle = 0.5; s1.penumbra = 0.5; scene.add(s1); const s2 = new THREE.SpotLight(0x6688ff, 600); s2.position.set(-30, 20, -30); scene.add(s2); const f = new THREE.DirectionalLight(0xffeebb, 0.8); f.position.set(0, 0, 50); scene.add(f); }
    function setupPostProcessing() { const r = new RenderPass(scene, camera); const b = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85); b.threshold = 0.7; b.strength = 0.45; b.radius = 0.4; composer = new EffectComposer(renderer); composer.addPass(r); composer.addPass(b); }
    function createTextures() { const c = document.createElement('canvas'); c.width = 128; c.height = 128; const x = c.getContext('2d'); x.fillStyle = '#ffffff'; x.fillRect(0, 0, 128, 128); x.fillStyle = '#880000'; x.beginPath(); for (let i = -128; i < 256; i += 32) { x.moveTo(i, 0); x.lineTo(i + 32, 128); x.lineTo(i + 16, 128); x.lineTo(i - 16, 0); } x.fill(); caneTexture = new THREE.CanvasTexture(c); caneTexture.wrapS = caneTexture.wrapT = THREE.RepeatWrapping; caneTexture.repeat.set(3, 3); }

    window.updateSnowSettings = () => { CONFIG.snow.sizeBase = parseFloat(document.getElementById('slider-snow-size').value); CONFIG.snow.count = parseInt(document.getElementById('slider-snow-count').value); createSnow(); };
    window.updateSnowSpeed = (v) => { CONFIG.snow.speed = parseFloat(v); };
    function createSnow() {
      if (snowInstancedMesh) { scene.remove(snowInstancedMesh); snowInstancedMesh.geometry.dispose(); snowInstancedMesh.material.dispose(); snowInstancedMesh = null; snowData = []; }
      if (CONFIG.snow.count <= 0) return;
      const g = new THREE.IcosahedronGeometry(CONFIG.snow.sizeBase, 0);
      const m = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0, roughness: 0.15, transmission: 0.9, thickness: 0.5, envMapIntensity: 1.5, clearcoat: 1, clearcoatRoughness: 0.1, ior: 1.33 });
      snowInstancedMesh = new THREE.InstancedMesh(g, m, CONFIG.snow.count); snowInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      for (let i = 0; i < CONFIG.snow.count; i++) {
        snowDummy.position.set((Math.random() - 0.5) * CONFIG.snow.range, Math.random() * CONFIG.snow.range, (Math.random() - 0.5) * CONFIG.snow.range);
        snowDummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        const s = 0.5 + Math.random() * CONFIG.snow.sizeVar; snowDummy.scale.set(s, s, s); snowDummy.updateMatrix();
        snowInstancedMesh.setMatrixAt(i, snowDummy.matrix);
        snowData.push({ vy: (Math.random() * 0.5 + 0.8), rx: (Math.random() - 0.5) * 2, ry: (Math.random() - 0.5) * 2, rz: (Math.random() - 0.5) * 2 });
      } scene.add(snowInstancedMesh);
    }

    class Particle {
      constructor(m, t, d = false) { this.mesh = m; this.type = t; this.isDust = d; this.posTree = new THREE.Vector3(); this.posScatter = new THREE.Vector3(); this.baseScale = m.scale.x; this.photoId = null; const s = (t === 'PHOTO') ? 0.3 : 2.0; this.spinSpeed = new THREE.Vector3((Math.random() - 0.5) * s, (Math.random() - 0.5) * s, (Math.random() - 0.5) * s); this.calcPos(); }
      calcPos() { const h = CONFIG.particles.treeHeight; let t = Math.pow(Math.random(), 0.8); const y = (t * h) - (h / 2); let rm = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t)); const a = t * 50 * Math.PI + Math.random() * Math.PI; const r = rm * (0.8 + Math.random() * 0.4); this.posTree.set(Math.cos(a) * r, y, Math.sin(a) * r); let rs = this.isDust ? (12 + Math.random() * 20) : (8 + Math.random() * 12); const th = Math.random() * Math.PI * 2, ph = Math.acos(2 * Math.random() - 1); this.posScatter.set(rs * Math.sin(ph) * Math.cos(th), rs * Math.sin(ph) * Math.sin(th), rs * Math.cos(ph)); }
      update(dt, mode, ft) {
        let tg = this.posTree; if (mode === 'SCATTER') tg = this.posScatter; else if (mode === 'FOCUS') { if (this.mesh === ft) { let off = new THREE.Vector3(0, 1, 38); if (STATE.focusType === 1) off.set(-4, 2, 35); else if (STATE.focusType === 2) off.set(3, 0, 32); else if (STATE.focusType === 3) off.set(0, -2.5, 30); const im = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert(); tg = off.applyMatrix4(im); } else tg = this.posScatter; }
        const ls = (mode === 'FOCUS' && this.mesh === ft) ? 8.0 : 4.0; this.mesh.position.lerp(tg, ls * dt);
        if (mode === 'SCATTER') { this.mesh.rotation.x += this.spinSpeed.x * dt; this.mesh.rotation.y += this.spinSpeed.y * dt; this.mesh.rotation.z += this.spinSpeed.z * dt; } else if (mode === 'TREE') { this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt); this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt); this.mesh.rotation.y += 0.5 * dt; }
        if (mode === 'FOCUS' && this.mesh === ft) { this.mesh.lookAt(camera.position); if (STATE.focusType === 1) this.mesh.rotateZ(0.38); if (STATE.focusType === 2) this.mesh.rotateZ(-0.15); if (STATE.focusType === 3) this.mesh.rotateX(-0.4); }
        let s = this.baseScale; if (this.isDust) { s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id)); if (mode === 'TREE') s = 0; } else if (mode === 'SCATTER' && this.type === 'PHOTO') s = this.baseScale * 2.5; else if (mode === 'FOCUS') { if (this.mesh === ft) { if (STATE.focusType === 2) s = 3.5; else if (STATE.focusType === 3) s = 4.8; else s = 3.0; } else s = this.baseScale * 0.8; } this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 6 * dt);
      }
    }

    function createParticles() {
      // 1. å®šä¹‰å‡ ä½•ä½“
      const sg = new THREE.SphereGeometry(0.5, 32, 32);
      const bg = new THREE.BoxGeometry(0.55, 0.55, 0.55);
      // æ‹æ–ç³–å½¢çŠ¶
      const c = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -0.5, 0),
        new THREE.Vector3(0, 0.3, 0),
        new THREE.Vector3(0.1, 0.5, 0),
        new THREE.Vector3(0.3, 0.4, 0)
      ]);
      const cg = new THREE.TubeGeometry(c, 16, 0.08, 8, false);

      // 2. å®šä¹‰æè´¨ (å…³é”®ä¿®æ”¹ï¼šå¼€å¯ transparent å¹¶åŠ å…¥ envMaterials åˆ—è¡¨)

      // é‡‘è‰²æè´¨
      const gm = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1,
        roughness: 0.1,
        envMapIntensity: 2,
        emissive: 0x443300,
        emissiveIntensity: 0.3,
        transparent: true // <--- å…³é”®ä¿®æ”¹ï¼šå¼€å¯é€æ˜
      });

      // ç»¿è‰²æè´¨
      const grm = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.deepGreen,
        metalness: 0.2,
        roughness: 0.8,
        emissive: 0x002200,
        emissiveIntensity: 0.2,
        transparent: true // <--- å…³é”®ä¿®æ”¹
      });

      // çº¢è‰²æè´¨
      const rm = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.accentRed,
        metalness: 0.3,
        roughness: 0.2,
        clearcoat: 1,
        emissive: 0x330000,
        transparent: true // <--- å…³é”®ä¿®æ”¹
      });

      // æ‹æ–ç³–æè´¨
      const cm = new THREE.MeshStandardMaterial({
        map: caneTexture,
        roughness: 0.4,
        transparent: true // <--- å…³é”®ä¿®æ”¹
      });

      // === å…³é”®æ­¥éª¤ï¼šå°†æè´¨åŠ å…¥å…¨å±€åˆ—è¡¨ ===
      // è¿™æ · animate å‡½æ•°é‡Œçš„é€»è¾‘æ‰èƒ½æ§åˆ¶å®ƒä»¬å˜æ·¡
      envMaterials.push(gm, grm, rm, cm);

      // 3. ç”Ÿæˆç²’å­ Mesh (åŸæœ‰é€»è¾‘)
      for (let i = 0; i < CONFIG.particles.count; i++) {
        const r = Math.random();
        let m, t;
        if (r < 0.4) { m = new THREE.Mesh(bg, grm); t = 'BOX'; }
        else if (r < 0.7) { m = new THREE.Mesh(bg, gm); t = 'GOLD_BOX'; }
        else if (r < 0.92) { m = new THREE.Mesh(sg, gm); t = 'GOLD_SPHERE'; }
        else if (r < 0.97) { m = new THREE.Mesh(sg, rm); t = 'RED'; }
        else { m = new THREE.Mesh(cg, cm); t = 'CANE'; }

        const s = 0.4 + Math.random() * 0.5;
        m.scale.set(s, s, s);
        m.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
        mainGroup.add(m);
        particleSystem.push(new Particle(m, t, false));
      }

      // 4. æ ‘é¡¶æ˜Ÿæ˜Ÿ (é¡ºä¾¿ä¹ŸåŠ ä¸Šé€æ˜æ§åˆ¶ï¼Œä¿è¯æ•´ä½“ä¸€è‡´)
      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffdd88,
        emissive: 0xffaa00,
        emissiveIntensity: 1,
        metalness: 1,
        roughness: 0,
        transparent: true // <--- å…³é”®ä¿®æ”¹
      });
      envMaterials.push(starMat); // åŠ å…¥æ§åˆ¶åˆ—è¡¨

      const st = new THREE.Mesh(new THREE.OctahedronGeometry(1.2, 0), starMat);
      st.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
      mainGroup.add(st);

      mainGroup.add(photoMeshGroup);
    }
    function createDust() {
      const geo = new THREE.TetrahedronGeometry(0.08, 0);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xffeebb,
        transparent: true,
        opacity: 0.8,
      });

      // === ä¿®æ”¹ç‚¹ï¼šåŠ å…¥åˆ—è¡¨ ===
      envMaterials.push(mat);

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }
    }
    function createDefaultPhotos() { const c = document.createElement('canvas'); c.width = 512; c.height = 512; const x = c.getContext('2d'); x.fillStyle = '#050505'; x.fillRect(0, 0, 512, 512); x.strokeStyle = '#eebb66'; x.lineWidth = 15; x.strokeRect(20, 20, 472, 472); x.font = '500 60px Times New Roman'; x.fillStyle = '#eebb66'; x.textAlign = 'center'; x.fillText("JOYEUX", 256, 230); x.fillText("NOEL", 256, 300); createPhotoTexture(c.toDataURL(), 'default'); }
    // === æ–°å¢ï¼šåˆ›å»º 3D ç²’å­æ–‡å­—ç³»ç»Ÿ ===
    // === ä¼˜åŒ–ç‰ˆï¼šé«˜å¯¹æ¯”åº¦ 3D ç²’å­æ–‡å­—ç³»ç»Ÿ ===
    function createCenterText() {
      textGroup = new THREE.Group();

      // --- 1. åˆ¶ä½œæ–‡å­—è´´å›¾ (Canvas) ---
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 1024;
      canvas.height = 512;

      const line1 = "æœ±é“­";
      const line2 = "åœ£è¯èŠ‚å¿«ä¹";

      // å…³é”®ä¼˜åŒ–Aï¼šæ·»åŠ ä¸€å±‚æ·±è‰²é˜´å½±ï¼ŒæŠŠæ–‡å­—å’Œäº®èƒŒæ™¯éš”å¼€
      ctx.shadowColor = "rgba(0, 0, 0, 0.8)"; // æ·±é»‘è‰²æŠ•å½±
      ctx.shadowBlur = 15;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 4;

      ctx.textAlign = "center";

      // ç¬¬ä¸€è¡Œå­—
      ctx.font = "bold 200px 'Times New Roman', serif";
      ctx.fillStyle = "#ffeebb"; // æ·¡å¥¶æ²¹è‰²ï¼Œæ¯”çº¯é‡‘æ›´äº®
      ctx.fillText(line1, 512, 180);

      // ç¬¬äºŒè¡Œå­— (ä¸»è§†è§‰)
      // å…³é”®ä¼˜åŒ–Bï¼šç»™ä¸»æ–‡å­—åŠ æ·±è‰²æè¾¹
      ctx.font = "italic 150px 'Times New Roman', serif";

      // å…ˆç”»æè¾¹ (Stroke)
      ctx.strokeStyle = "rgba(0, 0, 0, 0.3)"; // è½»å¾®çš„é»‘è‰²æè¾¹
      ctx.lineWidth = 8;
      ctx.strokeText(line2, 512, 340);

      // å†ç”»ä¸»ä½“ (Fill) - æ”¹ä¸ºçº¯ç™½è‰²ï¼Œæœ€å¼ºäº®åº¦
      ctx.fillStyle = "#ffffff";
      ctx.fillText(line2, 512, 340);

      // å†ç”»ä¸€å±‚é‡‘è‰²å…‰æ™•åœ¨ä¸Šé¢ (å¯é€‰ï¼Œå¢åŠ æ¢¦å¹»æ„Ÿ)
      ctx.shadowColor = "rgba(255, 200, 50, 0.8)"; // é‡‘è‰²å‘å…‰
      ctx.shadowBlur = 30;
      ctx.fillText(line2, 512, 340); // é‡å ç”»ä¸€æ¬¡äº§ç”Ÿå…‰æ™•

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;

      // --- 2. åˆ›å»ºæ–‡å­— Sprite ---
      // å…³é”®ä¼˜åŒ–Cï¼šä½¿ç”¨ NormalBlending è€Œä¸æ˜¯ Additive
      // Additive (å åŠ ) ä¼šè®©ç™½è‰²å˜é€æ˜ï¼ŒNormal (æ­£å¸¸) ä¼šè®©ç™½è‰²å®å®åœ¨åœ¨é®ä½åé¢çš„ç²’å­
      const mat = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0,
        depthWrite: false,
        // blending: THREE.AdditiveBlending // åˆ æ‰æˆ–æ³¨é‡Šæ‰è¿™è¡Œï¼Œä½¿ç”¨é»˜è®¤æ··åˆæ¨¡å¼ï¼Œå­—æ‰å¤Ÿå®ï¼
      });

      textSprite = new THREE.Sprite(mat);
      textSprite.scale.set(12, 6, 1);
      textGroup.add(textSprite);

      // --- 3. æ·»åŠ â€œæŠ¤å«â€ç²’å­ (å…‰ç¯) ---
      const geo = new THREE.BufferGeometry();
      const pos = [];
      const colors = [];
      const color1 = new THREE.Color(0xffd700); // é‡‘è‰²
      const color2 = new THREE.Color(0xffffff); // ç™½è‰²ç‚¹ç¼€

      for (let i = 0; i < 120; i++) { // ç¨å¾®å‡å°‘æ•°é‡ï¼Œé¿å…å¤ªä¹±
        // å…³é”®ä¼˜åŒ–Dï¼šåŠ å¤§åŠå¾„ (r)ï¼Œç»™æ–‡å­—ç•™å‡ºç©ºåœ°
        const r = 6.5 + Math.random() * 4; // ä» 4 æ”¹ä¸º 6.5ï¼Œæ¨è¿œä¸€ç‚¹
        const theta = Math.random() * Math.PI * 2;
        // å‹æ‰ä¸€ç‚¹ï¼Œå½¢æˆç¯çŠ¶
        const phi = (Math.random() - 0.5) * 1.2;

        pos.push(
          r * Math.cos(theta),
          r * Math.sin(phi) * 0.6,
          r * Math.sin(theta)
        );

        // éšæœºæ··ä¸€ç‚¹ç™½è‰²ç²’å­
        const c = Math.random() > 0.7 ? color2 : color1;
        colors.push(c.r, c.g, c.b);
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const starMat = new THREE.PointsMaterial({
        vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
        size: 0.2,          // ç¨å¾®å¤§ä¸€ç‚¹ç‚¹
        transparent: true,
        opacity: 0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        map: getDiscTexture() // ä½¿ç”¨åœ†å½¢çº¹ç†ï¼Œè®©ç²’å­æ›´åœ†æ¶¦
      });

      const auraStars = new THREE.Points(geo, starMat);
      auraStars.name = "aura";
      textGroup.add(auraStars);

      mainGroup.add(textGroup);
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆä¸€ä¸ªåœ†å½¢çš„ç²’å­çº¹ç† (è®©å…‰ç‚¹æ›´å¥½çœ‹)
    function getDiscTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 32, 32);
      const tex = new THREE.CanvasTexture(canvas);
      return tex;
    }
    function createPhotoTexture(b, id) { const i = new Image(); i.src = b; i.onload = () => { const t = new THREE.Texture(i); t.colorSpace = THREE.SRGBColorSpace; t.needsUpdate = true; addPhotoToScene(t, id, i); } }
    function addPhotoToScene(t, id, imgObj) {
      const aspect = imgObj.width / imgObj.height; let w = 1.2, h = 1.2; if (aspect > 1) h = w / aspect; else w = h * aspect;
      const fg = new THREE.BoxGeometry(w + 0.2, h + 0.2, 0.05); const fm = new THREE.MeshStandardMaterial({ color: 0xc5a059, metalness: 0.6, roughness: 0.5, envMapIntensity: 0.5 }); const f = new THREE.Mesh(fg, fm); const pg = new THREE.PlaneGeometry(w, h); const pm = new THREE.MeshBasicMaterial({ map: t }); const p = new THREE.Mesh(pg, pm); p.position.z = 0.04; const g = new THREE.Group(); g.add(f); g.add(p); const s = 0.8; g.scale.set(s, s, s); photoMeshGroup.add(g); const pt = new Particle(g, 'PHOTO', false); pt.photoId = id; pt.texture = t; particleSystem.push(pt);
    }
    window.applyParticleSettings = () => { const ph = particleSystem.filter(p => p.type === 'PHOTO'); const tr = []; mainGroup.children.forEach(c => { if (c !== photoMeshGroup) tr.push(c) }); tr.forEach(c => mainGroup.remove(c)); particleSystem = [...ph]; CONFIG.particles.count = parseInt(document.getElementById('slider-tree').value); CONFIG.particles.dustCount = parseInt(document.getElementById('slider-dust').value); createParticles(); createDust(); createSnow(); };

    async function initMediaPipe() { videoElement = document.getElementById('webcam-video'); if (navigator.mediaDevices?.getUserMedia) { try { const s = await navigator.mediaDevices.getUserMedia({ video: true }); videoElement.srcObject = s; videoElement.onloadedmetadata = () => { videoElement.play(); renderWebcamPreview() }; } catch (e) { console.error(e) } } try { const v = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"); handLandmarker = await HandLandmarker.createFromOptions(v, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" }, runningMode: "VIDEO", numHands: 1 }); predictWebcam(); } catch (e) { console.warn(e) } }
    function renderWebcamPreview() { const c = document.getElementById('webcam-canvas'), x = c.getContext('2d', { willReadFrequently: true }); function d() { if (videoElement.readyState >= 2) x.drawImage(videoElement, 0, 0, c.width, c.height); requestAnimationFrame(d) } d() }
    let lvt = -1; async function predictWebcam() { if (videoElement && videoElement.currentTime !== lvt && handLandmarker) { lvt = videoElement.currentTime; const r = handLandmarker.detectForVideo(videoElement, performance.now()); processGestures(r); document.getElementById('cam-status').classList.toggle('active', r.landmarks.length > 0); } requestAnimationFrame(predictWebcam); }
    function processGestures(r) { if (r.landmarks && r.landmarks.length > 0) { STATE.hand.detected = true; const lm = r.landmarks[0]; STATE.hand.x = (lm[9].x - 0.5) * 2; STATE.hand.y = (lm[9].y - 0.5) * 2; const thumb = lm[4], index = lm[8], wrist = lm[0], middle = lm[12]; const pd = Math.hypot(thumb.x - index.x, thumb.y - index.y); const od = Math.hypot(middle.x - wrist.x, middle.y - wrist.y); if (STATE.mode === 'FOCUS') { if (pd > 0.1) setMode('SCATTER'); return; } if (pd < 0.05 && STATE.mode !== 'FOCUS') triggerPhotoGrab(); else if (od > 0.4) setMode('SCATTER'); else if (od < 0.2) setMode('TREE'); } else STATE.hand.detected = false; }

    window.setupEvents = () => {
      window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight) });
      document.getElementById('file-input').addEventListener('change', e => { Array.from(e.target.files).forEach(f => { const r = new FileReader(); r.onload = ev => { const i = new Image(); i.src = ev.target.result; i.onload = () => { const id = savePhotoToDB(ev.target.result); createPhotoTexture(ev.target.result, id) } }; r.readAsDataURL(f) }) });
      document.getElementById('music-input').addEventListener('change', e => { const f = e.target.files[0]; if (f) { saveMusicToDB(f); bgmAudio.src = URL.createObjectURL(f); bgmAudio.play().then(() => { isMusicPlaying = true; updatePlayBtnUI(true) }).catch(console.error) } });

      // é”®ç›˜äº¤äº’
      window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        const code = e.code;
        const k = e.key.toLowerCase();

        if (k === 'h') window.toggleUI();
        if (code === 'Space') { e.preventDefault(); setMode('TREE'); }
        if (k === 'z') setMode('SCATTER');
        if (k === 'x') triggerPhotoGrab();

        if (code === 'ArrowUp') manualRotateState.x = -1;
        if (code === 'ArrowDown') manualRotateState.x = 1;
        if (code === 'ArrowLeft') manualRotateState.y = -1;
        if (code === 'ArrowRight') manualRotateState.y = 1;
      });
      window.addEventListener('keyup', (e) => {
        const code = e.code;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(code)) manualRotateState = { x: 0, y: 0 };
      });
    }
    window.openDeleteManager = async () => { document.getElementById('delete-manager').classList.remove('hidden'); const g = document.getElementById('photo-grid'); g.innerHTML = ''; const ps = await loadPhotosFromDB(); if (!ps || ps.length === 0) g.innerHTML = '<div style="color:#888;">æš‚æ— ç…§ç‰‡</div>'; else ps.forEach(p => { const d = document.createElement('div'); d.className = 'photo-item'; const i = document.createElement('img'); i.className = 'photo-thumb'; i.src = p.data; const b = document.createElement('div'); b.className = 'delete-x'; b.innerText = 'X'; b.onclick = e => { e.stopPropagation(); confirmDelete(p.id, d) }; d.appendChild(i); d.appendChild(b); g.appendChild(d) }) }
    window.confirmDelete = (id, el) => { deletePhotoFromDB(id); el.remove(); const p = particleSystem.find(pa => pa.photoId === id); if (p) { photoMeshGroup.remove(p.mesh); particleSystem.splice(particleSystem.indexOf(p), 1) } }
    window.clearAllPhotos = () => { if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç…§ç‰‡å—ï¼Ÿ")) { clearPhotosDB(); particleSystem.filter(p => p.type === 'PHOTO').forEach(p => photoMeshGroup.remove(p.mesh)); particleSystem = particleSystem.filter(p => p.type !== 'PHOTO'); window.openDeleteManager() } }
    window.closeDeleteManager = () => { document.getElementById('delete-manager').classList.add('hidden') }

    function animate() {
      requestAnimationFrame(animate); const dt = clock.getDelta(); const et = clock.getElapsedTime();
      if (snowInstancedMesh && STATE.mode === 'TREE') {
        snowInstancedMesh.visible = true;
        for (let i = 0; i < CONFIG.snow.count; i++) {
          snowInstancedMesh.getMatrixAt(i, snowDummy.matrix); snowDummy.matrix.decompose(snowDummy.position, snowDummy.quaternion, snowDummy.scale); const d = snowData[i];
          snowDummy.position.y -= d.vy * CONFIG.snow.speed * dt; snowDummy.position.x += Math.sin(et * 0.5 + i) * 2.5 * dt; snowDummy.position.z += Math.cos(et * 0.3 + i) * 1.5 * dt;
          snowDummy.rotation.x += d.rx * dt; snowDummy.rotation.y += d.ry * dt; snowDummy.rotation.z += d.rz * dt;
          if (snowDummy.position.y < -25) { snowDummy.position.y = 40; snowDummy.position.x = (Math.random() - 0.5) * CONFIG.snow.range; snowDummy.position.z = (Math.random() - 0.5) * CONFIG.snow.range; }
          snowDummy.updateMatrix(); snowInstancedMesh.setMatrixAt(i, snowDummy.matrix);
        } snowInstancedMesh.instanceMatrix.needsUpdate = true;
      } else if (snowInstancedMesh) snowInstancedMesh.visible = false;

      // Updated Rotation Logic
      if (manualRotateState.x !== 0 || manualRotateState.y !== 0) { const s = CONFIG.interaction.rotationSpeed * 2.0; STATE.rotation.x += manualRotateState.x * s * dt; STATE.rotation.y += manualRotateState.y * s * dt; }
      else if (STATE.mode === 'SCATTER' && STATE.hand.detected) { const th = 0.3, s = CONFIG.interaction.rotationSpeed; if (STATE.hand.x > th) STATE.rotation.y -= s * dt * (STATE.hand.x - th); else if (STATE.hand.x < -th) STATE.rotation.y -= s * dt * (STATE.hand.x + th); if (STATE.hand.y < -th) STATE.rotation.x += s * dt * (-STATE.hand.y - th); else if (STATE.hand.y > th) STATE.rotation.x -= s * dt * (STATE.hand.y - th); }
      else { if (STATE.mode === 'TREE') { STATE.rotation.y += 0.3 * dt; STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt; } else STATE.rotation.y += 0.1 * dt; }

      mainGroup.rotation.y = STATE.rotation.y; mainGroup.rotation.x = STATE.rotation.x;
      particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));

      // === æ–°å¢ï¼šæ§åˆ¶æ–‡å­—å’Œå…‰ç¯çš„æ˜¾éš ===
      const titleEl = document.getElementById('title-container');
      if (textGroup && textSprite) {
        const aura = textGroup.getObjectByName("aura");

        // === çŠ¶æ€ 1: æ•£å¼€æ¨¡å¼ (æ˜¾ç¤ºä¸­å¿ƒæ–‡å­—ï¼Œéšè—é¡¶éƒ¨æ ‡é¢˜) ===
        if (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') {

          // 1. ä¸­å¿ƒæ–‡å­— & å…‰ç¯ï¼šæ·¡å…¥
          textSprite.material.opacity = THREE.MathUtils.lerp(textSprite.material.opacity, 1, dt * 1.5);
          if (aura) {
            aura.material.opacity = THREE.MathUtils.lerp(aura.material.opacity, 0.8, dt * 1.5);
            aura.rotation.y -= dt * 0.1; // å…‰ç¯æ—‹è½¬
          }
          // æ–‡å­—å‘¼å¸åŠ¨ç”»
          const s = 12 + Math.sin(clock.elapsedTime * 2) * 0.2;
          textSprite.scale.set(s, s * 0.5, 1);

          // 2. é¡¶éƒ¨ HTML æ ‡é¢˜ï¼šæ·¡å‡º
          if (titleEl) {
            // è·å–å½“å‰é€æ˜åº¦ï¼Œé»˜è®¤ä¸º1
            let currOp = titleEl.style.opacity === '' ? 1 : parseFloat(titleEl.style.opacity);
            titleEl.style.opacity = THREE.MathUtils.lerp(currOp, 0, dt * 3.0); // 3.0 è¡¨ç¤ºæ¶ˆå¤±å¾—ç¨å¾®å¿«ä¸€ç‚¹
            if (currOp < 0.1) titleEl.style.pointerEvents = 'none'; // å˜é€æ˜åç¦æ­¢é¼ æ ‡ç‚¹å‡»ï¼Œé˜²æ­¢è¯¯è§¦
          }

        }
        // === çŠ¶æ€ 2: èšåˆæ¨¡å¼ (éšè—ä¸­å¿ƒæ–‡å­—ï¼Œæ˜¾ç¤ºé¡¶éƒ¨æ ‡é¢˜) ===
        else {

          // 1. ä¸­å¿ƒæ–‡å­— & å…‰ç¯ï¼šæ·¡å‡º
          textSprite.material.opacity = THREE.MathUtils.lerp(textSprite.material.opacity, 0, dt * 4.0);
          if (aura) aura.material.opacity = THREE.MathUtils.lerp(aura.material.opacity, 0, dt * 4.0);

          // 2. é¡¶éƒ¨ HTML æ ‡é¢˜ï¼šæ·¡å…¥
          if (titleEl) {
            let currOp = titleEl.style.opacity === '' ? 1 : parseFloat(titleEl.style.opacity);
            titleEl.style.opacity = THREE.MathUtils.lerp(currOp, 1, dt * 2.0);
            titleEl.style.pointerEvents = 'auto'; // æ¢å¤é¼ æ ‡äº¤äº’ï¼ˆå¦‚æœä½ å¼€å¯äº†æ ‡é¢˜æ‹–æ‹½åŠŸèƒ½ï¼‰
          }
        }
      }
      const targetEnvOpacity = (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') ? 0.15 : 1.0;

      // éå†æ‰€æœ‰ç¯å¢ƒæè´¨ï¼Œå¹³æ»‘è¿‡æ¸¡
      envMaterials.forEach(mat => {
        // åªæœ‰å½“æè´¨å­˜åœ¨ä¸”éœ€è¦æ›´æ–°æ—¶æ‰è®¡ç®—
        if (mat) {
          mat.opacity = THREE.MathUtils.lerp(mat.opacity, targetEnvOpacity, dt * 2.0);
          // æ€§èƒ½ä¼˜åŒ–ï¼šå¦‚æœä¸é€æ˜åº¦å‡ ä¹ä¸º 1ï¼Œå°±æŠŠ transparent å…³æ‰é˜²æ­¢æ·±åº¦æ’åºé—®é¢˜ï¼ˆå¯é€‰ï¼Œä¸åŠ ä¹Ÿæ²¡äº‹ï¼‰
          // mat.transparent = mat.opacity < 0.99; 
        }
      });
      composer.render();
    }
    init();
  </script>
</body>

</html>